/*
c++ -ggdb stems.cpp -o stems sims/util.o sims/geom.o -lm


*/
#include "sims/util.hpp"
#include "sims/geom.hpp"

typedef struct {
	char	*res;	// residue type
	float	*acc;	// surface accesssibility
	int	*sec;	// secondary structure type (0=c, 1=A, 2=B, 3=3ten)
	int	*rid;	// residue number
	Vec	*cas;	// P position (runs 1...N with dummy 0 and N+1)
	Vec	*cbs;	// dummy CB/centroid (extended <bond>A from CA)
	int	len;	// chain length
	int	gaps;	// number of chain breaks
	float	pcta, pctb;	// percent alpha and beta structure
} Prot;

char	aa3[2222][4];

void addres ( Vec* cas, int i, int j, int k, int add ) {
// Add a new residue position <add> off the end of the chain away from mid <j> and <k>
Vec	m = cas[j] & cas[k];
Vec	v = m - cas[i];
	cas[add] = m+v;
}

void extend ( Prot* chain ) {
// Add dummy CA atoms to the end of the chain
int	n = chain->len, m = n+1; 
        addres(chain->cas,  3,  2,1, 0);	// add res 0 to Nterm
        addres(chain->cas,n-2,n-1,n, m);	// add res N+1 to Cterm
	chain->res[0] = 'n';
	chain->res[m] = 'c';
}

void add_cb ( Prot *chain, float bond ) {
// Add dummy atom to the chain (but not to 0 or N+1)
        FIR(i,chain->len) { Vec n,c,b; float d;
		n = (chain->cas[i] - chain->cas[i-1]).getNorm();
		c = (chain->cas[i] - chain->cas[i+1]).getNorm();
		b = (n+c).getNorm()*bond;
		chain->cbs[i] = chain->cas[i]+b;
        }
}

void getpdb ( Prot* chain, FILE *pdb ) { 
// Read a PDB format file from stream <pdb> into structure Prot 1..N
int	io, n = 1;
char	line[222], junk[30];
Vec	xyz[2222];
float	acc[2222];
        while(1) { float x,y,z, s,t; int a,b; char c;
		io = read_line(pdb,line);
		if ( io < 1 ) break;
		if (!strncmp(line,"END",3)) break;
		if (!strncmp(line,"TER",3)) continue; // LINKs may follow
		if (strncmp(line,"ATOM   ",7) && strncmp(line,"HETATM ",7)) continue; // MSE is a HETATM
		if (strncmp(line+13,"P  ",3)) continue;
		sscanf(line,"%30c %f%f%f%f%f", junk, &x, &y, &z, &s, &t);
		xyz[n].x = x; xyz[n].y = y; xyz[n].z = z; acc[n] = t;
		strncpy(aa3[n],junk+17,3);
		n++;
	}
	chain->len = n-1;
	n++; // 2 extra positions for dummy chain extensions
	chain->cas = new Vec[n];
	chain->cbs = new Vec[n];
	chain->sec = new int[n];
	chain->rid = new int[n];
	chain->res = new char[n];
	chain->acc = new float[n];
	FIR(i,chain->len) {
		chain->cas[i].x = xyz[i].x;
		chain->cas[i].y = xyz[i].y;
		chain->cas[i].z = xyz[i].z;
		chain->acc[i] = acc[i];
	}
	extend(chain);		// add 0 and N+1 positions
	add_cb(chain,2.0);	// add pseudo CB/centroid
}

float** getmat ( Prot *chain )
{
int	len = chain->len, lenn = len+2; // allow for dummy atoms 0 and N+1
float	**mat = new float*[lenn];
	FOR(i,lenn) mat[i] = new float[lenn];
	FOR(i,lenn) FOR(j,lenn) {
		mat[i][j] = 0.0;
		if (i<j) mat[i][j] = chain->cas[i] | chain->cas[j];
		if (i>j) mat[i][j] = chain->cbs[i] | chain->cbs[j];
	}
	return mat;
}

Vec rogs ( Prot *A, float *w ) {
// get the weighted RoG around a rough bundle axis
int	m, n, in, len = A->len;
Vec	*c = new Vec[len];
Pairs	*p = new Pairs[999];	
int	q[999];
Seg	axis;
Vec	cog, move;
Vec	sum, rog;
	m = n = 0;
	cog.zero();
	FIR(i,len) { // caps have weight = 1
		if ( w[i]>0.5) { cog += A->cas[i]; m++; }
		if ( w[i]>0.5 && w[i]<1.5) c[n++] = A->cas[i];
	}
	cog /= (float)m;
	m = 0;
	FOR(i,n-8) { // for pairs of cap residues...
		for (int j=i-1; j<i+8; j++) // between adjacent caps
		{ float	d = c[i] | c[j];
			if (d < 30.0) continue;
			p[m].a = i; p[m].b = j; p[m].s = d; m++;
			if (m==999) break;
		}
	}
	sort(p,q,m); // reverse sort with rank in <q[]>
	axis.A = c[p[q[0]].a]; axis.B = c[p[q[0]].b]; // first axis guess is widest cap pair
	in = 1;
	FOR(j,m)
	{ int	i = q[j], pa = p[i].a, pb = p[i].b;
	  Vec	a = c[pa], b = c[pb];
	  Seg	now = (axis.A/(float)j, axis.B/(float)j);
	  float dA = a|now.A, dB = a|now.B;
		if (dA < dB) {
			axis.A += a; axis.B += b; 
		} else {
			axis.A += b; axis.B += a;
		} 
	}
	axis.A /= (float)m;
	axis.B /= (float)m;
	move = cog-(axis.A & axis.B);
	axis.A += move; axis.B += move;
	// the bundle axis is now centred on the CoG of the TM segments
	rog.zero(); sum.zero();
	FIR(i,len)
	{ float d = axis.vec_to_line(A->cas[i]),
		dd = d*d, wi = w[i];
		rog.x += dd;    sum.x += 1.0;
		rog.y += dd*wi; sum.y += wi;
		wi += 0.5;
		rog.z += dd*wi; sum.z += wi;
	}
	rog.x /= sum.x; rog.x = sqrt(rog.x);
	rog.y /= sum.y; rog.y = sqrt(rog.y);
	rog.z /= sum.z; rog.z = sqrt(rog.z);
	return rog;
}

// 1 = pdb file, 2 = constraints file

int main (int argc, char** argv) {
// XYZ from simprot realigned with tube axis along Z (1st pdb line = prot.dat top GROUP line)
Vec	rms, rog;
float	sum0, sum1, sum2;
int	n, len, in=500;
char	line[111];
Pairs	cons[1111];
float	**dij;
Prot	*chain = new Prot;
FILE	*con = fopen(argv[1],"r");
FILE	*pdb = fopen(argv[2],"r");
FILE	*seg = fopen("line.plot","r");
float	want, give, bump = 4.0;
int	ncon, nseg, nbump = 0;
int	segW[22][2], segC[22][2], five[22], rank[22];
	getpdb(chain,pdb);
	fclose(pdb);
	dij = getmat(chain); // i<j=CA i>j=CB
	len = chain->len;
	FOR(i,len) FOR(j,len) { float d;
		if (i<j) continue;
		if (i-j < 5) continue;
		d = chain->cas[i] | chain->cas[j];
		if (d < bump) nbump++;
	}
	Pi(nbump) NL
	n = 0;
	FOR(i,in) { int a,b,c,d; float s;
		if (read_line(con,line) <= 0) break;
		sscanf(line,"%d %d %d %d %f", &a, &b, &c, &d, &s);
		if (a>b) { int e=a; a=b; b=e; } // keep a<b
		if (d>9000) d -= 9000; // added to stop early breaks in sim
		cons[n].a = a;
		cons[n].b = b;
		cons[n].s = s;
		n++;
	}
	ncon = n;
	nseg = 1;
	n = 0;
	DO { int io, i, j;
		io = read_line(seg,line);
		if (io < 0) break;
		if (io < 9) {	// next seg
			n = 0;
			continue;
		} else {	// get ends
			sscanf(line,"%d %d", &i, &j);
			segW[nseg][n] = i; segC[nseg][n] = j;
			n++;
		}
		if (n>1) nseg++;
	}
	Pi(nseg) NL
	five[0] = 0;
	FIR(i,nseg-1)
	{ int	w0 = segW[i][0], w1 = segW[i][1],
		c0 = segC[i][0], c1 = segC[i][1];
		// make all 5'--> 3'
		if (w1 < w0) { n = w0; w0 = w1; w1 = n; }
		if (c1 < c0) { n = c0; c0 = c1; c1 = n; }
		// lowest start first
		if (w0 < c0) {
			segW[i][0] = w0; segW[i][1] = w1;
			segC[i][0] = c0; segC[i][1] = c1;
		} else { // swap
			segW[i][0] = c0; segW[i][1] = c1;
			segC[i][0] = w0; segC[i][1] = w1;
		}
		five[i] = segW[i][0];
	}
	five[nseg] = len;
	sort(five,rank,-(nseg+1));
	// add dummy terminal markers
	segC[0][1] = segW[0][1] = 0;
	segW[nseg][0] = segC[nseg][0] = len;
	FIR(j,nseg-1)
	{ int	i = rank[j],
		w0 = segW[i][0], w1 = segW[i][1],
		c0 = segC[i][0], c1 = segC[i][1];
		Pi(w0) Pi(w1) Pt(---) Pi(c0) Pi(c1) NL
	} NL
	pdb = fopen("stems.pdb","w");
	FIR(j,nseg-1)
	{ int	i = rank[j], last, next,
		w0 = segW[i][0], w1 = segW[i][1],
		c0 = segC[i][0], c1 = segC[i][1];
		last = segC[rank[j-1]][1];
Pi(last) NL
printf("%d segW = %3d -%3d\n",j,w0,w1);
		for (int k=w0; k<=w1; k++) {
			fprintf(pdb,"ATOM%7d  P     G A%4d     %7.3f %7.3f %7.3f  0.00  0.00\n", k,k,
				chain->cas[k].x, chain->cas[k].y, chain->cas[k].z);
		}
		fprintf(pdb,"\n");
		n = c0-w1;
		if (n>1) {  int gap, mingap = n;	// something between
			next = c0;
			FOR(k,nseg) {	// look for closest end to w1
				if (k==i) continue;
				//        seg starts - end of last strand 
				gap = abs(segW[k][0] - w1);
				if (gap < mingap) { next = segW[k][0]; mingap = gap; }
				gap = abs(segC[k][0] - w1);
				if (gap < mingap) { next = segC[k][0]; mingap = gap; }
			} 
			next -= mingap/2;
printf("%d gap1 = %3d -%3d\n",j,w1+1,next);
			for (int k=w1+1; k<=next; k++) {
				fprintf(pdb,"ATOM%7d  P     G A%4d     %7.3f %7.3f %7.3f  0.00  0.00\n", k,k,
					chain->cas[k].x, chain->cas[k].y, chain->cas[k].z);
			}
			fprintf(pdb,"\n");
		}
Pt(:) NL
		if (n>3) {  int gap, mingap = n;	// write the other half
			last = w1;
			FOR(k,nseg) {	// look for closest end to c0
				if (k==i) continue;
				//        seg finish - start of next strand
				gap = abs(segW[k][1] - c0);
				if (gap < mingap) { last = segW[k][1]; mingap = gap; }
				gap = abs(segC[k][1] - c0);
				if (gap < mingap) { last = segC[k][1]; mingap = gap; }
			} 
			last += mingap/2;
			if (last==next) last++;
printf("%d gap2 = %3d -%3d\n",j,last,c0-1);
			for (int k=last; k<c0; k++) {
				fprintf(pdb,"ATOM%7d  P     G A%4d     %7.3f %7.3f %7.3f  0.00  0.00\n", k,k,
					chain->cas[k].x, chain->cas[k].y, chain->cas[k].z);
			}
			fprintf(pdb,"\n");
		}
printf("%d segC = %3d -%3d\n",j,c0,c1);
		for (int k=c0; k<=c1; k++) {
			fprintf(pdb,"ATOM%7d  P     G A%4d     %7.3f %7.3f %7.3f  0.00  0.00\n", k,k,
				chain->cas[k].x, chain->cas[k].y, chain->cas[k].z);
		}
		fprintf(pdb,"TER\n");
		next = segW[rank[j+1]][0];
Pi(next) NL
NL
	}
	fclose(pdb);
}
