%\TT{tinker}, \TT{sorter}, \TT{center} and \TT{looker} will be described.

\section{Minor routines}

\subsection{\TT{tinker}}

Steric exclusion combined with the range of linkage described above can generate
a relatively stable structure.   However, given the background of "thermal" noise
generated by \TT{shaker}, any less constrained parts of the structure will be free
to diverge from their starting configuration under the given distance constraints. 
Typically, this involves twisting and shearing that can generate large motions with
little violation of the specified distances although, in principle, distances cannot
constrain chirality.  A general mechanism, based only on local angles and distances
was provided to reduce these distortions and was applied equally to all levels
that form a chain.  The routine that implements this fixing is \TT{tinker}.

In a chain segment of five units (designated: b2,b1,c0,a1,a2), six distances were
recorded from the starting configuration in the upper half of the matrix of pairwise
distances excluding adjacent units.  Three angles were also recored as b1-c0-a1 and
the torsion angles around b1-c0 and c0-a1.   The innermost three distances are held
the vector {\tt prox} with the others in {\tt dist} and the three angles in {\tt geom}
all of which form part of the data associated with every object (in the {\tt Cell} class).
The distances are firstly refined in the routine {\tt fixDist()} followed by (mainly)
the angles in {\tt fixGeom()}

The starting values for the three vectors come from the starting model but, unlike
fixed bond lengths, these local values can be continually updated as the simulation
progresses.  Distances can be regularised with little disruption,
however, refining torsion angles can sometimes lead to an error propagation
with dramatic effects.  To limit the potential for this the torsion angles were
dialled-up exactly to generate new positions for b2 (b2') and a2 (a2').   These were
used to form a basis-set of unit length vectors along: $x = a2'-b2', y = c0-(a2'+b2')/2$,
with $z$ mutually orthogonal.   Starting from the centroid of the five points, the
coefficients of an equivalent basis-set defined on the original positions were applied
to the new basis-set to generate the new coordinate positions.  The result is a
compromise between angle and position that remains stable over repeated application.
The core code for {\tt fixGeom()} is given below and should be self-explanatory.
\begin{singlespace}
\ \\
------------------------------------------------------------------------------------------------------
\begin{tiny}
\begin{verbatim}
float fixgeom ( Cell *cell, float fix )
	:
// quality checks
	d = vdif(b1->xyz,a1->xyz);
	dlo = c0->prox.y*(1.0-good);
	dhi = c0->prox.y*(1.0+good);
	if (d<dlo || d>dhi) return 99.9; // proximal distance too poor
	d = vdif(b2->xyz,a2->xyz);
	dlo = c0->dist.y*(1.0-good);
	dhi = c0->dist.y*(1.0+good);
	if (d<dlo || d>dhi) return 99.9; // distal distance too poor
	d = angle(b2->xyz,c0->xyz,a2->xyz)*180/PI;
	if (d < 30.0 || d > 150.0) return 0.0; // base triangle too thin
	t1 = torsion(b2->xyz,b1->xyz,c0->xyz,a1->xyz);
	if (t1>999.0) { Pt(Bad t1 in) Pi(cell->uid) NL
		Pv(b2->xyz) NL Pv(b1->xyz) NL Pv(c0->xyz) NL Pv(a1->xyz) NL exit(1);
	}
	th = angle(b1->xyz, c0->xyz, a1->xyz);
	t2 = torsion(a2->xyz,a1->xyz,c0->xyz,b1->xyz);
	if (t2>999.0) { Pt(Bad t2 in) Pi(cell->uid) NL
		Pv(a2->xyz) NL Pv(a1->xyz) NL Pv(c0->xyz) NL Pv(b1->xyz) NL exit(1);
	}
	dt1old = angdif(t1,tau1);
	dthold = angdif(th,theta);
	dt2old = angdif(t2,tau2);
	if (dt1old+dthold+dt2old > 3.0) return 99.9; // too far to fix
// configuration close enough to fix
	xyz[0] = b2->xyz; xyz[1] = b1->xyz;
	xyz[2] = c0->xyz;
	xyz[3] = a1->xyz; xyz[4] = a2->xyz;
	// dial-up correct torsion angles
	t1 = torsion(xyz[3],xyz[2],xyz[1],xyz[0]);
	xyz[0].get_rot(xyz[2],xyz[1],tau1-t1);
	t2 = torsion(xyz[1],xyz[2],xyz[3],xyz[4]);
	xyz[4].get_rot(xyz[2],xyz[3],tau2-t2);
	t1 = torsion(xyz[0], xyz[1], xyz[2], xyz[3]);
	th = angle(xyz[1], xyz[2], xyz[3]);
	t2 = torsion(xyz[1], xyz[2], xyz[3], xyz[4]);
	dt1new = angdif(t1,tau1);
	dthnew = angdif(th,theta);
	dt2new = angdif(t2,tau2);
	// fit positions xyz[0,2,4] to b2,c0,a2
	x = xyz[4]- xyz[0];
	mid = xyz[4] & xyz[0];
	y = xyz[2] - mid;
	z = x^y;
	mat = Mat(x.norm(), y.norm(), z.norm()); // new unit basis vectors in mat
	wat = mat.get_inv();
	mid = (xyz[0] + xyz[2] + xyz[4])/3.0;	// new CoG
	for (i=0; i<5; i++) {  // get xyz from centre in terms of basis set coeficients (abc)
		xyz[i] -= mid;
		abc[i] = wat * xyz[i];
	}
	x = a2->xyz - b2->xyz;
	mid = a2->xyz & b2->xyz;
	y = c0->xyz - mid;
	z = x^y;
	x.setVec(); y.setVec(); z.setVec();		// old basis vectors
	mid = (b2->xyz + c0->xyz + a2->xyz)/3.0;	// old CoG
	for (i=0; i<5; i++) {	// reconstruct new positions with old basis vectors
		xyz[i] = mid;	// start at centre and sum basis vector components
		xyz[i] += x * abc[i].x;
		xyz[i] += y * abc[i].y;
		xyz[i] += z * abc[i].z;
	}

	t1 = torsion(xyz[0], xyz[1], xyz[2], xyz[3]);
	th = angle(xyz[1], xyz[2], xyz[3]);
	t2 = torsion(xyz[1], xyz[2], xyz[3], xyz[4]);
	dt1new = angdif(t1,tau1);
	dthnew = angdif(th,theta);
	dt2new = angdif(t2,tau2);
	if (dt1new>dt1old || dthnew>dthold || dt2new>dt2old) return 0.0;
// shift towards new positions (by fix) if all angles better
	shift = (xyz[0]-b2->xyz)*fix; moveCell(b2,shift);
	shift = (xyz[1]-b1->xyz)*fix; moveCell(b1,shift);
	shift = (xyz[2]-c0->xyz)*fix; moveCell(c0,shift);
	shift = (xyz[3]-a1->xyz)*fix; moveCell(a1,shift);
	shift = (xyz[4]-a2->xyz)*fix; moveCell(a2,shift);
	t1 = torsion(b2->xyz,b1->xyz,c0->xyz,a1->xyz);
	th = angle(b1->xyz, c0->xyz, a1->xyz);
	t2 = torsion(a2->xyz,a1->xyz,c0->xyz,b1->xyz);
	t1 = angdif(t1,tau1);
	th = angdif(th,theta);
	t2 = angdif(t2,tau2);
	tt = t1 + th + t2;
	return tt;
}
\end{verbatim}
\end{tiny}
------------------------------------------------------------------------------------------------------
\end{singlespace}

Although only local information is used, its application over all levels leads to a
global effect which is almost sufficient by itself to recapitulate a full structure
\footnote{
Applied to the chemotaxis protein {\tt 3chy} (130 residues), if no helices get 
trapped on the wrong side of the sheet and with a few links between the terminal helices,
the recapitulated structure can come as close as 5\AA\ RMSD (over all CA atoms).
}.
As the procedure was designed to correct defects caused by the addition of random
motion (by \TT{shaker}), it was not implemented as an independent parallel process
but included in the thread along with \TT{shaker} and applied after the coordinates
had been displaced, so keeping a balance between disruption and correction.

{\tt tinker} can be applied in two different modes depending on the setting of the
global parameter {\tt TINKER [update]}.   In static mode, the starting
distances and angles remain unchanged throughout the simulation, while in dynamic mode
they are updated with a frequency set by {\tt update}.  With a value of $N$, \TT{tinker}
is called on every $N^{th}$ cycle of the simulation.  An update value less than zero (or
no value) is taken to specify the static mode.   If the {\tt TINKER} command is not
given, then \TT{tinker} is skipped.

The overall effect of the \TT{tinker} procedure is
to provide a buffering effect against random motion and is similar to giving
inertia to the structure but still allowing movement under a persistent "force".
In the current implementation, this shift is by 1\% once in roughly every 100
activations of \TT{tinker}.

\subsection{\TT{fixers}}

The routines collected here share the common feature that they are designed to
maintain specialised geometries, usually associated with both protein and nucleic acid
secondary structures.   Many of them use the vector of distances contained in {\tt cent},
the three components of which hold the distance of the child to it parent's centre and
both end-points.

The \TT{fixers} are all bundled into the same thread.

\subsubsection{{\tt fixSSEaxis}}

For protein secondary structures (\A\ and \B), rather than calculate the inertial axes
which is not only slow but also inaccurate for short \AHs, an axis was defined using the
mid-points of positions $i-1$ and $i+1$.  The axis direction is built-up by the addition
of displacements from one mid-point to the next, as:
\begin{singlespace}
\ \\
------------------------------------------------------------------------------------------------------
\begin{tiny}
\begin{verbatim}
        :
        axis.zero();
        was = cell->child[2]->xyz & cell->child[0]->xyz;
        for (i=2; i<n-1; i++) { // +/- 1 line is close to axis for alpha and beta
                now = cell->child[i-1]->xyz & cell->child[i+1]->xyz;
                axis += now - was;
                was = now;
                in++;
        }
        :
\end{verbatim}
\end{tiny}
------------------------------------------------------------------------------------------------------
\end{singlespace}
The resulting axis is taken as the direction along which to place the new axis end-points
at a distance calculated by what is expected from the number of residues in the SSE and
their known rise per residue (with an approximation for loops) as:
\begin{singlespace}
\ \\
------------------------------------------------------------------------------------------------------
\begin{tiny}
\begin{verbatim}
        :
        // reset the end-points relative to the centre
        if (sort==0) len = loopAXIS*size*sqrt(fn+1.0);
        if (sort==1) len = alphAXIS*fn*bondCA/3.8;
        if (sort==2) len = betaAXIS*fn*bondCA/3.8;
        axis.setVec(len*0.5);
        x = cell->xyz - axis;
        shift = x - cell->endN;
        cell->endN += shift*weight;
        y = cell->xyz + axis;
        shift = y - cell->endC;
        cell->endC += shift*weight;
        :
\end{verbatim}
\end{tiny}
------------------------------------------------------------------------------------------------------
\end{singlespace}
The values of {\tt loopAXIS}, {\tt alphAXIS} and {\tt betaAXIS} are: 0.5, 1,5 and 3.0, respectively.

The positions of the children are then refined relative to the new end-points using the values in
the vector {\tt cent}.   As these may be inconsistent, a consensus shift is calculated, weighted
by the distance from each of the three points.
\begin{singlespace}
\ \\
------------------------------------------------------------------------------------------------------
\begin{tiny}
\begin{verbatim}
        :
        DO(i,n) { Cell *kidi = cell->child[i]; Vec dif; float rms1, rms2;
                dif.x = kidi->xyz|cell->endN;
                dif.y = kidi->xyz|cell->xyz;
                dif.z = kidi->xyz|cell->endC;
                dif -= kidi->cent; // difference between have and want (cent) 
                rms1 = sqrt(dif*dif);
                shift.zero();
                shift += (cell->endN - kidi->xyz)*dif.x;
                shift += (cell->xyz  - kidi->xyz)*dif.y;
                shift += (cell->endC - kidi->xyz)*dif.x;
                shift *= 0.0;//weight/3;
                now = kidi->xyz + shift;
                dif.x = now|cell->endN;
                dif.y = now|cell->xyz;
                dif.z = now|cell->endC;
                dif -= kidi->cent;
                rms2 = sqrt(dif*dif);
                if (rms1-rms2 > NOISE) { // apply the shift
                        kidi->xyz = now;
                }
        }
        :
\end{verbatim}
\end{tiny}
------------------------------------------------------------------------------------------------------
\end{singlespace}
The improvement in the new position is monitored as a difference in RMSD, but this should
not be necessary.

\subsubsection{{\tt fixRNAaxis}}


\subsubsection{{\tt fixRNAstem}}


\subsubsection{{\tt fixDOMaxis}}


\subsubsection{{\tt fixSheet}}


\subsection{\TT{center}}

The \TT{center} routine was introuced previously as the process that couples
the position of a parent to its children and except for \TT{keeper} (which only
acts on individual children) is the only routine to cross between levels of the 
hierarchy.  The code is simple enough to show in its entirity but there are a
few aspects that will be discussed below.
\begin{singlespace}
\ \\
------------------------------------------------------------------------------------------------------
\begin{tiny}
\begin{verbatim}
void center ()
{
Cell    *world = Cell::world;
        DO(i,world->kids) { Cell *child = world->child[i];
                if (child->empty) continue;
                child->group();
        }
}

void Cell::group () {
        this->shifter( 0.5 );
        for (int i=0; i<kids; i++) child[i]->group();
}

void Cell::shifter ( const float couple )
{ // shift child centroid to cell centre by couple and cell to centroid by 1-couple
Vec     shift, s;
float   wkids = 0.0;
        if (kids==0) return;
        shift = xyz - this->getWcent();         // shift for children towards cell centre
        s = shift * couple;                     // scale by coupling constant
        DO(i,kids) moveCell(child[i],s,1);      // move children (and all their offspring) home
        s = shift * (1.0 - couple);             // scale by 1-couple
        xyz -= s; endN -= s; endC -= s;         // shift shell (parent and poles) towards children
}
\end{verbatim}
\end{tiny}
------------------------------------------------------------------------------------------------------
\end{singlespace}
The centroid of the children is calculated by the routine {\tt getWcent()} which returns the
centroid with each child weighted by the number of children it contains, plus 1. All the kids
are then shifted along the line between the centroid and the centre of the parent by a factor
{\tt couple}, which has a built-in value of 0.5.   The parent in turn is shifted towards the
children by the complementary factor 1-{\tt couple}.

\subsection{\TT{sorter}}

For all obects above the atomic level, the \TT{viewer} uses transparent rendering.
Whereas normal solid objects are automatically sorted into and drawn from a Z-buffer,
for some reason this is not done for transparent objects.   As the view changes, 
three sorted buffers in X,Y and Z are maintained and the quadrant that is closest to
the viewer is used to set the ranking.  As \NAME\ is not striving for perfect rendering,
these buffers are resorted only intermittently using a single pass of a bubble sort and in
a complex field of objects, the occassional mis-layering of the objects is seldom noticed.

Irrespective of graphical rendering, the buffers also have uses in finding pairs of
neighbouring objects.
